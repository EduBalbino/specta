use std::{borrow::Cow, collections::HashMap, path::Path};

use specta::TypeCollection;

use crate::{primitives, Error};

/// Allows you to configure how Specta's Typescript exporter will deal with BigInt types ([i64], [i128] etc).
///
/// WARNING: None of these settings affect how your data is actually ser/deserialized.
/// It's up to you to adjust your ser/deserialize settings.
#[derive(Debug, Clone, Default)]
pub enum BigIntExportBehavior {
    /// Export BigInt as a Typescript `string`
    ///
    /// Doing this is serde is [pretty simple](https://github.com/serde-rs/json/issues/329#issuecomment-305608405).
    String,
    /// Export BigInt as a Typescript `number`.
    ///
    /// WARNING: `JSON.parse` in JS will truncate your number resulting in data loss so ensure your deserializer supports large numbers.
    Number,
    /// Export BigInt as a Typescript `BigInt`.
    ///
    /// You must ensure you deserializer is able to support this.
    BigInt,
    /// Abort the export with an error.
    ///
    /// This is the default behavior because without integration from your serializer and deserializer we can't guarantee data loss won't occur.
    #[default]
    Fail,
}

/// Typescript language exporter.
#[derive(Debug, Clone)]
#[non_exhaustive]
pub struct Typescript {
    pub header: Cow<'static, str>,
    pub framework_header: Cow<'static, str>,
    pub bigint: BigIntExportBehavior,
    pub serde: bool,
    pub(crate) jsdoc: bool,
}

impl Default for Typescript {
    fn default() -> Self {
        Self {
            header: Cow::Borrowed(""),
            framework_header: Cow::Borrowed(
                "// This file has been generated by Specta. DO NOT EDIT.",
            ),
            bigint: Default::default(),
            serde: false,
            jsdoc: false,
        }
    }
}

impl Typescript {
    /// Construct a new Typescript exporter with the default options configured.
    pub fn new() -> Self {
        Default::default()
    }

    /// Override the header for the exported file.
    /// You should prefer `Self::header` instead unless your a framework.
    #[doc(hidden)] // Although this is hidden it's still public API.
    pub fn framework_header(mut self, header: impl Into<Cow<'static, str>>) -> Self {
        self.framework_header = header.into();
        self
    }

    /// Configure a header for the file.
    ///
    /// This is perfect for configuring lint ignore rules or other file-level comments.
    pub fn header(mut self, header: impl Into<Cow<'static, str>>) -> Self {
        self.header = header.into();
        self
    }

    /// Configure the BigInt handling behaviour
    pub fn bigint(mut self, bigint: BigIntExportBehavior) -> Self {
        self.bigint = bigint;
        self
    }

    /// TODO: Explain
    pub fn with_serde(mut self) -> Self {
        self.serde = true;
        self
    }

    /// TODO
    pub fn export(&self, types: &TypeCollection) -> Result<String, Error> {
        let mut out = self.header.to_string();
        if !out.is_empty() {
            out.push('\n');
        }
        out += &self.framework_header;
        out.push_str("\n\n");

        let mut map = HashMap::with_capacity(types.len());
        for dt in types.into_unsorted_iter() {
            if let Some((existing_sid, existing_impl_location)) =
                map.insert(dt.name().clone(), (dt.sid(), dt.location()))
            {
                if existing_sid != dt.sid() {
                    return Err(Error::DuplicateTypeName {
                        types: (dt.location(), existing_impl_location),
                        name: dt.name().clone(),
                    });
                }
            }
        }

        if self.serde {
            specta_serde::validate(types)?;
        }

        for ndt in types.into_sorted_iter() {
            out += &primitives::export(self, &types, &ndt)?;
            out += "\n\n";
        }

        Ok(out)
    }

    /// TODO
    pub fn export_to(&self, path: impl AsRef<Path>, types: &TypeCollection) -> Result<(), Error> {
        let path = path.as_ref();
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        std::fs::write(
            &path,
            self.export(types).map(|s| format!("{}{s}", self.header))?,
        )?;
        Ok(())
    }
}
