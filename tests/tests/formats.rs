use std::{fs::read_to_string, path::PathBuf};

use specta::{
    builder::NamedDataTypeBuilder,
    datatype::{DataType, Primitive},
    Type, TypeCollection,
};
use specta_typescript::Format;

#[derive(Type)]
pub struct Testing {
    a: testing::Testing,
}

#[derive(Type)]
pub struct Another {
    bruh: String,
}

#[derive(Type)]
pub struct MoreType {
    u: String,
}

mod testing {
    use super::*;

    #[derive(Type)]
    pub struct Testing {
        b: testing2::Testing,
    }

    mod testing2 {
        use super::*;

        #[derive(Type)]
        pub struct Testing {
            c: String,
        }
    }
}

#[test]
fn test_formats_with_duplicate_typename() {
    let types = TypeCollection::default()
        .register::<Testing>()
        .register::<Another>()
        .register::<MoreType>();

    assert_eq!(
        specta_typescript::Typescript::new()
            .export(&types)
            .map_err(|e| e
                .to_string()
                .starts_with("Detected multiple types with the same name")),
        Err(true)
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .format(Format::FlatFile)
            .export(&types)
            .map_err(|e| e
                .to_string()
                .starts_with("Detected multiple types with the same name")),
        Err(true)
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .format(Format::ModulePrefixedName)
            .export(&types)
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type integration_tests_formats_Another = { bruh: string };\n\nexport type integration_tests_formats_MoreType = { u: string };\n\nexport type integration_tests_formats_Testing = { a: integration_tests_formats_testing_Testing };\n\nexport type integration_tests_formats_testing_testing2_Testing = { c: string };\n\nexport type integration_tests_formats_testing_Testing = { b: integration_tests_formats_testing_testing2_Testing };".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .format(Format::Namespaces)
            .export(&types)
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nimport $$specta_ns$$integration_tests::formats = integration_tests::formats;\n\nimport $$specta_ns$$integration_tests::formats::testing = integration_tests::formats::testing;\n\nimport $$specta_ns$$integration_tests::formats::testing::testing2 = integration_tests::formats::testing::testing2;\n\nexport namespace integration_tests::formats {\n    export type Another = { bruh: string };\n\n    export type MoreType = { u: string };\n\n    export type Testing = { a: $$specta_ns$$integration_tests.formats.testing.Testing };\n\n    export namespace testing {\n        export type Testing = { b: $$specta_ns$$integration_tests.formats.testing.testing2.Testing };\n\n        export namespace testing2 {\n            export type Testing = { c: string };\n\n        }\n    }\n}\nexport namespace integration_tests::formats::testing {\n    export type Testing = { b: $$specta_ns$$integration_tests.formats.testing.testing2.Testing };\n\n    export namespace testing2 {\n        export type Testing = { c: string };\n\n    }\n}\nexport namespace integration_tests::formats::testing::testing2 {\n    export type Testing = { c: string };\n\n}".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .format(Format::Files)
            .export(&types)
            .map_err(|e| e.to_string()),
        Err("Unable to export type\n".into())
    );

    let _handle = DeleteOnDrop("_test_types");

    specta_typescript::Typescript::new()
        .format(Format::Files)
        .export_to("./_test_types", &types)
        .unwrap();

    assert_eq!(
        read_to_string("_test_types/integration_tests/formats.ts").map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\nimport { Testing as integration_tests_formats_testing_Testing } from \"./../integration_tests/formats/testing\";\n\nexport type Another = { bruh: string };\n\nexport type MoreType = { u: string };\n\nexport type Testing = { a: integration_tests_formats_testing_Testing };".into())
    );

    assert_eq!(
        read_to_string("_test_types/integration_tests/formats/testing.ts")
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\nimport { Testing as integration_tests_formats_testing_testing2_Testing } from \"./../../integration_tests/formats/testing/testing2\";\n\nexport type Testing = { b: integration_tests_formats_testing_testing2_Testing };".into())
    );

    assert_eq!(
        read_to_string("_test_types/integration_tests/formats/testing/testing2.ts")
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type Testing = { c: string };".into())
    );
}

#[test]
fn test_formats_without_duplicate_typename() {
    let types = TypeCollection::default()
        .register::<Another>()
        .register::<MoreType>();

    assert_eq!(
        specta_typescript::Typescript::new()
            .export(&types)
            .map_err(|e| e
                .to_string()
                .starts_with("Detected multiple types with the same name")),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type Another = { bruh: string };\n\nexport type MoreType = { u: string };".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .format(Format::FlatFile)
            .export(&types)
            .map_err(|e| e
                .to_string()
                .starts_with("Detected multiple types with the same name")),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type Another = { bruh: string };\n\nexport type MoreType = { u: string };".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .format(Format::ModulePrefixedName)
            .export(&types)
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type integration_tests_formats_Another = { bruh: string };\n\nexport type integration_tests_formats_MoreType = { u: string };".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .format(Format::Namespaces)
            .export(&types)
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nimport $$specta_ns$$integration_tests::formats = integration_tests::formats;\n\nexport namespace integration_tests::formats {\n    export type Another = { bruh: string };\n\n    export type MoreType = { u: string };\n\n}".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .format(Format::Files)
            .export(&types)
            .map_err(|e| e.to_string()),
        Err("Unable to export type\n".into())
    );
}

#[test]
fn test_empty_module_path() {
    let mut types = TypeCollection::default();
    types
        .create(NamedDataTypeBuilder::new(
            "testing",
            Default::default(),
            DataType::Primitive(Primitive::i8),
        ))
        .unwrap();

    // types
    //     .create(
    //         NamedDataTypeBuilder::new(
    //             "testing2",
    //             Default::default(),
    //             DataType::Primitive(Primitive::i8),
    //         )
    //         .module_path("testing"),
    //     )
    //     .unwrap();

    assert_eq!(
        specta_typescript::Typescript::new()
            .format(Format::FlatFile)
            .export(&types)
            .map_err(|e| e
                .to_string()
                .starts_with("Detected multiple types with the same name")),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type testing = number;".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .format(Format::ModulePrefixedName)
            .export(&types)
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type virtual_testing = number;".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .format(Format::Namespaces)
            .export(&types)
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nimport $$specta_ns$$virtual = virtual;\n\nexport namespace virtual {\n    export type testing = number;\n\n}".into())
    );

    let _handle = DeleteOnDrop("_unnamed_test");

    specta_typescript::Typescript::new()
        .format(Format::Files)
        .export_to("./_unnamed_test", &types)
        .unwrap();

    assert_eq!(
        read_to_string("_unnamed_test/virtual.ts")
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type testing = number;".into())
    );
}

struct DeleteOnDrop(pub &'static str);
impl Drop for DeleteOnDrop {
    fn drop(&mut self) {
        std::fs::remove_dir_all(self.0).ok();
    }
}
